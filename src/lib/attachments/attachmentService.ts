/**
 * FEAT-066: Attachment service for upload preparation and download with caching.
 *
 * Upload: encrypt file with feed AES key -> compute SHA-256 hash -> return ref + blob
 * Download: check cache -> if miss, fetch via streaming -> cache result -> return
 */

import { aesEncryptBytes, aesDecryptBytes } from '../crypto/encryption';
import { computeSha256 } from './attachmentHash';
import { AttachmentCache } from './attachmentCache';
import type {
  AttachmentRef,
  AttachmentBlob,
  AttachmentUploadData,
  DownloadProgress,
} from './types';
import { MAX_ATTACHMENT_SIZE, MAX_ATTACHMENTS_PER_MESSAGE } from './types';

/** Callback for download progress updates. */
export type ProgressCallback = (progress: DownloadProgress) => void;

/** Function signature for the gRPC streaming download (injected at integration time). */
export type StreamingDownloadFn = (
  attachmentId: string,
  feedId: string,
  requesterUserAddress: string,
  thumbnailOnly: boolean,
) => Promise<Uint8Array>;

// Module-level cache instance (lazy initialized)
let cacheInstance: AttachmentCache | null = null;

/** Get or create the shared cache instance. */
export function getAttachmentCache(): AttachmentCache {
  if (!cacheInstance) {
    cacheInstance = new AttachmentCache();
  }
  return cacheInstance;
}

/** Replace the cache instance (for testing). */
export function setAttachmentCache(cache: AttachmentCache): void {
  cacheInstance = cache;
}

/**
 * Validate attachment count and sizes before upload.
 * @param files Array of files to validate
 * @returns Error message if invalid, null if valid
 */
export function validateAttachments(files: { size: number }[]): string | null {
  if (files.length > MAX_ATTACHMENTS_PER_MESSAGE) {
    return `Too many attachments: ${files.length} exceeds the maximum of ${MAX_ATTACHMENTS_PER_MESSAGE}`;
  }

  for (const file of files) {
    if (file.size > MAX_ATTACHMENT_SIZE) {
      const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
      return `Attachment is ${sizeMB}MB, exceeds the maximum of 25MB`;
    }
  }

  return null;
}

/**
 * Prepare a single attachment for upload.
 * Encrypts the file with the feed AES key and computes the SHA-256 hash.
 *
 * @param fileBytes Original file content as Uint8Array
 * @param fileName Original file name
 * @param mimeType MIME type (e.g. 'image/jpeg')
 * @param aesKeyBase64 Feed's AES-256 key (base64)
 * @param thumbnailBytes Optional thumbnail bytes (for images, already generated by caller)
 * @returns AttachmentUploadData with ref (on-chain metadata) and blob (encrypted bytes)
 */
export async function prepareAttachmentForUpload(
  fileBytes: Uint8Array,
  fileName: string,
  mimeType: string,
  aesKeyBase64: string,
  thumbnailBytes?: Uint8Array,
): Promise<AttachmentUploadData> {
  // Validate size
  if (fileBytes.byteLength > MAX_ATTACHMENT_SIZE) {
    const sizeMB = (fileBytes.byteLength / (1024 * 1024)).toFixed(1);
    throw new Error(`Attachment is ${sizeMB}MB, exceeds the maximum of 25MB`);
  }

  // Generate UUID
  const attachmentId = crypto.randomUUID();

  // Compute SHA-256 hash of original plaintext
  const hash = await computeSha256(fileBytes);

  // Encrypt original
  const encryptedOriginal = await aesEncryptBytes(fileBytes, aesKeyBase64);

  // Encrypt thumbnail if provided
  let encryptedThumbnail: Uint8Array | null = null;
  if (thumbnailBytes) {
    encryptedThumbnail = await aesEncryptBytes(thumbnailBytes, aesKeyBase64);
  }

  const ref: AttachmentRef = {
    id: attachmentId,
    hash,
    mimeType,
    size: fileBytes.byteLength,
    fileName,
  };

  const blob: AttachmentBlob = {
    attachmentId,
    encryptedOriginal,
    encryptedThumbnail,
  };

  return { ref, blob };
}

/**
 * Download an attachment, checking cache first.
 * Returns the decrypted original bytes.
 *
 * @param attachmentId Attachment UUID
 * @param feedId Feed UUID for authorization
 * @param requesterUserAddress User's public signing address
 * @param aesKeyBase64 Feed's AES-256 key for decryption
 * @param downloadFn The gRPC streaming download function (injected)
 * @param thumbnailOnly Whether to download only the thumbnail
 * @returns Decrypted file bytes
 */
export async function downloadAttachment(
  attachmentId: string,
  feedId: string,
  requesterUserAddress: string,
  aesKeyBase64: string,
  downloadFn: StreamingDownloadFn,
  thumbnailOnly: boolean = false,
): Promise<Uint8Array> {
  const cache = getAttachmentCache();
  const variant = thumbnailOnly ? 'thumbnail' : 'original';

  // Check cache first
  const cached = await cache.get(attachmentId, variant as 'original' | 'thumbnail');
  if (cached) {
    // Decrypt cached encrypted bytes
    return aesDecryptBytes(cached, aesKeyBase64);
  }

  // Cache miss - download from server
  const encryptedBytes = await downloadFn(
    attachmentId,
    feedId,
    requesterUserAddress,
    thumbnailOnly,
  );

  // Cache the encrypted bytes for future access
  await cache.set(attachmentId, encryptedBytes, variant as 'original' | 'thumbnail');

  // Decrypt and return
  return aesDecryptBytes(encryptedBytes, aesKeyBase64);
}
